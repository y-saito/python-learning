# 作業報告書

- 作成日時: 2026-02-21 19:09:49
- 対象プロジェクト: `python-learning`
- 報告範囲: お題4（SQL連携と分析クエリ）の実装・比較・検証

## 1. 実施サマリ

PostgreSQL テーブル `sales_orders` から売上明細を取得し、`Python` / `Node.js` / `PHP` の3実装で同一スキーマの分析レポートを出力した。
お題4では「SQLで抽出」「アプリ側で再集計」の責務分離を統一し、3言語の書き方差分を比較した。

## 2. 追加・更新ファイル

1. 実装
- `app/data_processing/sql_sales_report.py`
- `comparisons/topic4/sql_sales_report_node.js`
- `comparisons/topic4/sql_sales_report_php.php`

2. データ
- `data/topic4_sales_seed.sql`
- `data/topic4_sales_expected.json`

3. 依存・ドキュメント
- `requirements.txt`
  - `sqlalchemy==2.0.43`
  - `psycopg[binary]==3.2.10`
- `README.md`
  - お題4のシード投入・3言語実行・期待値比較手順を追記。

## 3. 共通仕様（I/F）

- 入力:
  - PostgreSQL テーブル `sales_orders`
  - 高額注文しきい値 `--high-value-threshold`（デフォルト `500`）
- 出力キー:
  - `summary`
  - `daily_sales`
  - `segment_sales`
  - `payment_method_sales`
  - `high_value_orders`

### 3.1 集計ルール
- `daily_sales`: `order_date` ごとの売上合計
- `segment_sales`: `customer_segment` ごとの売上合計・注文件数・平均売上
- `payment_method_sales`: `payment_method` ごとの売上合計・注文件数・平均売上
- `high_value_orders`: `order_amount >= threshold` の注文一覧

## 4. 行程別比較（Node.js / PHP / Python）

### 行程1: SQL接続と抽出
- Node.js:
  - `pg` で接続し、`SELECT ... FROM sales_orders` の結果を `rows` で取得。
- PHP:
  - `PDO`（`pgsql`）で接続し、`fetchAll(PDO::FETCH_ASSOC)` で取得。
- Python:
  - `sqlalchemy` + `pandas.read_sql_query()` で DataFrame 化。
- Python が得意な点:
  - 抽出後すぐ DataFrame 演算へ接続でき、分析処理の連結が短い。

### 行程2: 再集計（日次・セグメント・決済手段）
- Node.js:
  - `Map` を集計バッファにしてループ加算。
- PHP:
  - 連想配列を集計バッファにして `foreach` で加算。
- Python:
  - `groupby + agg + sort_values` で宣言的に集計。
- Python が得意な点:
  - 集計軸と集計式を1か所にまとめやすく、観点追加時の差分が小さい。

### 行程3: 高額注文抽出
- Node.js:
  - `filter` でしきい値判定し、配列ソートで順序固定。
- PHP:
  - `foreach` 中にしきい値判定して配列追加、`usort` で順序固定。
- Python:
  - 列条件 `df["order_amount"] >= threshold` で抽出し、DataFrame ソート。
- Python が得意な点:
  - 条件抽出を列演算で書けるため、監査観点（閾値変更・複合条件）を拡張しやすい。

### 行程4: JSON出力整形
- Node.js:
  - 配列オブジェクトを手動組み立て。
- PHP:
  - 連想配列を手動組み立て。
- Python:
  - DataFrame から辞書配列へ変換して整形。
- Python が得意な点:
  - 中間結果検証（DataFrame表示）と最終整形の往復がしやすい。

## 5. 実行コマンド（Docker 経由）

1. DB起動とシード投入
```bash
docker compose up -d db
docker compose exec -T db psql -U app -d app < data/topic4_sales_seed.sql
```

2. Python
```bash
docker compose run --rm app python -m app.data_processing.sql_sales_report > /tmp/topic4_py.json
```

3. Node.js
```bash
docker run --rm -v "$PWD":/workspace -w /workspace node:20 sh -lc \
  "cd /tmp && npm init -y >/dev/null && npm install pg@8.16.3 >/dev/null && \
   NODE_PATH=/tmp/node_modules node /workspace/comparisons/topic4/sql_sales_report_node.js" \
  > /tmp/topic4_node.json
```

4. PHP
```bash
docker run --rm -v "$PWD":/workspace -w /workspace php:8.3-cli bash -lc \
  "apt-get update >/dev/null && apt-get install -y --no-install-recommends libpq-dev >/dev/null && \
   docker-php-ext-install pdo_pgsql >/dev/null && \
   php /workspace/comparisons/topic4/sql_sales_report_php.php" \
  > /tmp/topic4_php.json
```

5. 一致検証
```bash
diff -u <(jq -S . data/topic4_sales_expected.json) <(jq -S . /tmp/topic4_py.json)
diff -u <(jq -S . data/topic4_sales_expected.json) <(jq -S . /tmp/topic4_node.json)
diff -u <(jq -S . data/topic4_sales_expected.json) <(jq -S . /tmp/topic4_php.json)
```

## 6. 検証結果

- 3言語すべて `data/topic4_sales_expected.json` と差分なし。
- `summary`:
  - `total_rows`: 12
  - `date_range_start`: `2026-02-01`
  - `date_range_end`: `2026-02-06`
  - `total_revenue`: 2161.25
  - `high_value_order_count`: 2

## 7. 品質チェック

- `docker compose run --rm --no-deps app ruff check app` -> `All checks passed!`
- `docker compose run --rm --no-deps app mypy app` -> `Success: no issues found in 9 source files`

## 8. 見るべきポイント（次回レビュー用）

1. SQLとアプリ側集計の責務分離
- Node.js / PHP / Python すべてで、SQLは「明細抽出」に留め、集計はアプリ側で実施しているか。
- Pythonは `read_sql_query -> DataFrame集計` の流れが自然につながっているか。

2. 集計ロジック追加時の差分量
- 例として「地域別売上（region）」を追加した場合、どの言語で変更箇所が最小になるか。
- Pythonは `groupby` 追加、Node.js/PHP は集計バッファ追加になる点を比較する。

3. 高額注文ルール変更への追従性
- `--high-value-threshold` の値変更時に、3言語で出力が同じ条件で変わるか。
- 複合条件（例: `segment='Enterprise' AND order_amount>=X`）を足したときの書きやすさを比較する。

4. 出力順固定と差分検証の安定性
- 日付順・売上降順などの並び順が固定され、`diff` が毎回安定するか。
- Pythonは `sort_values`、Node.js/PHP は `sort/usort` で同等順序を保てているか。

5. 実務運用を見据えた接続方式
- 学習段階ではCLI引数で接続情報を渡せるが、実務では `.env` / Secret 管理へ移す必要がある点を押さえる。
- Node.js は `pg`、PHP は `PDO(pgsql)`、Python は `sqlalchemy + psycopg` という選択肢の役割差を理解する。

## 9. お題4 完了判定

以下を満たしたため、お題4を完了とする。

1. PostgreSQL 抽出 + アプリ側再集計の流れを3言語で統一した。
2. 同一I/F・同一JSONスキーマで出力を一致させた。
3. 比較観点（実装方式・可読性・拡張性）を行程単位で記録した。
4. 期待値比較、lint、型チェックを通過した。

## 10. コメント運用ルール（次回以降必須）

次回以降の全お題で、最終アウトプットJSONを組み立てる箇所について以下を必須とする。

1. 返却オブジェクト直下の各キー（例: `summary`, `daily_sales`）に用途コメントを付与する。
2. ネストしたオブジェクトの各項目（例: `total_rows`, `date_range_start`）にも項目コメントを付与する。
3. 配列要素オブジェクト（例: `daily_sales[]`, `high_value_orders[]`）の各フィールドにもコメントを付与する。
4. コメントは日本語を基本とし、Node.js / PHP / Python の3実装で同じ意味になるよう統一する。

## 11. 補足サンプル（SQLModel利用時のDataFrame化）

本お題のPython実装は `pandas.read_sql_query` を使用したが、アプリが SQLModel を使っている場合でも DataFrame 化は可能。

```python
from sqlmodel import SQLModel, Field, Session, select, create_engine
import pandas as pd

class SalesOrder(SQLModel, table=True):
    order_id: str = Field(primary_key=True)
    order_date: str
    customer_segment: str
    payment_method: str
    order_amount: float

engine = create_engine("postgresql+psycopg://app:app@db:5432/app")

with Session(engine) as session:
    stmt = select(
        SalesOrder.order_id,
        SalesOrder.order_date,
        SalesOrder.customer_segment,
        SalesOrder.payment_method,
        SalesOrder.order_amount,
    )
    # SQLModel(Session) + pandas の連携で DataFrame 化
    df = pd.read_sql(stmt, session.connection())
```

- Node.js 比較:
  - `pg` で取得した `rows` を配列処理するのと同じ位置づけで、Pythonは `DataFrame` に直結できる。
- PHP 比較:
  - `PDO::fetchAll()` 後に配列集計するのと同じ位置づけで、Pythonは列演算（`groupby/agg`）へ接続できる。

## 12. 最終完了判定（確定）

品質チェック結果:
- `docker compose run --rm --no-deps app ruff check app` -> `All checks passed!`
- `docker compose run --rm --no-deps app mypy app` -> `Success: no issues found in 9 source files`

上記を満たしたため、お題4は完了とする。
